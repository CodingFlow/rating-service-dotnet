using System;
using System.Collections.Generic;
using System.Linq;
using ByteBard.AsyncAPI.Models;
using ByteBard.AsyncAPI.Models.Interfaces;
using Microsoft.CodeAnalysis;

namespace AsyncApiBindingsGenerator
{
    internal static class OutputGenerator
    {
        public static (string source, string className) GenerateSpecOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var @namespace = assemblyName;
            var serviceNamespacePart = @namespace.Split('.').First();
            var channels = spec.Channels;
            var addressMessages = channels.Select(channel => (channel.Value.Address, channel.Value.Messages.First().Value));
            var splitAddressesMessages = addressMessages.Select(((string address, AsyncApiMessage message) addressMessage) =>
            {
                var parts = addressMessage.address.Split('.');

                var serialized = addressMessage.message.SerializeAsJson(ByteBard.AsyncAPI.AsyncApiVersion.AsyncApi3_0);
                
                return (parts.First(), parts.ElementAt(1), addressMessage.message);
            });

            var formattedDependencies = splitAddressesMessages.Select(((string restMethod, string pathPart, AsyncApiMessage message) addressInfo) =>
            {
                var interfaceName = $"I{ToPascalCase(addressInfo.restMethod)}{ToPascalCase(addressInfo.pathPart)}Handler";
                var variableName = $"{addressInfo.restMethod}{ToPascalCase(addressInfo.pathPart)}Handler";
                return $"{interfaceName} {variableName}";
            });

            var formattedCases = splitAddressesMessages.Select(((string restMethod, string pathPart, AsyncApiMessage message) addressInfo) =>
            {
                var methodName = GetCaseMethodName(addressInfo.restMethod);
                var variableName = $"{addressInfo.restMethod}{ToPascalCase(addressInfo.pathPart)}Handler";
                var requestJsonInfo = GetFormattedRequestJsonInfo(addressInfo, spec);

                return $@"            case (""{addressInfo.restMethod}"", ""{addressInfo.pathPart}""):
                await restHandler.{methodName}(client, message, {variableName}{requestJsonInfo}, cancellationToken);
                break;";
            });

            var source =
$@"// <auto-generated/>
#nullable restore

using System.Text.Json.Nodes;
using NATS.Client.JetStream;
using NATS.Net;
using Service.Api.Common;
using {serviceNamespacePart}.Application.Handlers;

namespace {@namespace};

internal class RequestDispatcher({string.Join(", ", formattedDependencies)}) : IRequestDispatcher
{{
    public async Task DispatchRequest(NatsClient client, (string httpMethod, string pathPart) splitSubject, NatsJSMsg<Request<JsonNode>> message, IRestHandler restHandler, CancellationToken cancellationToken)
    {{
        switch (splitSubject)
        {{
{string.Join(@"
", formattedCases)}
        }}
    }}
}}
";

            return (source, "RequestDispatcher");
        }

        private static string GetFormattedRequestJsonInfo((string restMethod, string pathPart, AsyncApiMessage message) addressInfo, AsyncApiDocument spec)
        {
            return addressInfo.restMethod == "post"
                ? GetRequestJsonInfo(addressInfo, spec)
                : string.Empty;
        }

        private static string GetRequestJsonInfo((string restMethod, string pathPart, AsyncApiMessage message) addressInfo, AsyncApiDocument spec)
        {
            var MethodNamePart = $"{ToPascalCase(addressInfo.restMethod)}{ToPascalCase(addressInfo.pathPart)}Handler";
            var channelMessageSchema = addressInfo.message.Payload.Schema.As<AsyncApiJsonSchema>();
            var requestBodySchema = channelMessageSchema.Properties.First(p => p.Key == "body");
            var requestBodyItemsSchema = requestBodySchema.Value.Items;
            var schemas = spec.Components.Schemas;
            var requestType = schemas.First(m => requestBodyItemsSchema.Equals(m.Value.Schema.As<AsyncApiJsonSchema>())).Key;
            var formattedRequestType = $"{ToPascalCase(requestType)}Array";

            return $", SourceGenerationContext{MethodNamePart}.Default.{formattedRequestType}";
        }

        private static string GetCaseMethodName(string restMethod)
        {
            switch (restMethod.ToLower())
            {
                case "get":
                    return "HandleGet";
                case "post":
                    return "HandlePost";
                case "put":
                    return "HandlePut";
                case "delete":
                    return "HandleDelete";
                case "patch":
                    return "HandlePatch";
                default:
                    throw new ArgumentException($"Unsupported REST method: {restMethod}");
            }
        }

        private static string ToPascalCase(string input)
        {
            return $"{char.ToUpper(input[0])}{input.Substring(1)}";
        }
    }
}
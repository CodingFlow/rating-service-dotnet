using System;
using System.Collections.Generic;
using System.Linq;
using AsyncApiBindingsGenerator.TraversalStrategies;
using AsyncApiBindingsGenerator.Utils;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;
using static AsyncApiBindingsGenerator.Utils.StringUtils;

namespace AsyncApiBindingsGenerator
{
    internal static class ValidationExtensionsGenerator
    {
        public static (string source, string className) Generate(AsyncApiDocument spec, string assemblyName)
        {
            var @namespace = assemblyName;
            var serviceNamespacePart = @namespace.Split('.').First();

            var infos = spec.Operations.Values
                .SelectMany(operation =>
                {
                    var parts = operation.Channel.Address.Split('.');
                    var (restMethod, pathPart) = (parts.First(), parts.ElementAt(1));

                    var requestNamespacePart = GetRequestNamespacePart(restMethod);

                    var requestTypeName = $"{ToPascalCase(restMethod)}{ToPascalCase(pathPart)}{GetRequestType(restMethod)}";
                    var className = $"{requestTypeName}Validator";

                    var requestSchema = operation.Channel.Messages.First().Value.Payload.Schema.As<AsyncApiJsonSchema>();
                    requestSchema.Properties.TryGetValue("body", out var body);

                    var validatedType = $"{ToPascalCase(restMethod)}{ToPascalCase(pathPart)}{GetRequestType(restMethod)}";
                    var validatorName = $"{validatedType}Validator";

                    return ProcessingUtils.CreateTraversal(new ValidationExtensionsInput
                    {
                        Schema = body,
                        ValidatedType = validatedType,
                        ValidatorName = validatorName,
                    }, new ValidationExtensionsStrategy(), spec);
                });

            var registrations = infos.Select(info =>
            {
                return $"services.AddSingleton<IValidator<{info.ValidatedType}>, {info.ValidatorName}>();";
            });

            var formattedRegistrations = string.Join(@"
        ", registrations);

            var source = $@"// <auto-generated/>
#nullable restore

using System.Text.Json.Nodes;
using FluentValidation;
using Microsoft.Extensions.DependencyInjection;
using Service.Api.Common;
using {serviceNamespacePart}.Api.Validators;
using {serviceNamespacePart}.Application.Commands;
using {serviceNamespacePart}.Application.Models;
using {serviceNamespacePart}.Application.Queries;
using {serviceNamespacePart}.Application.QueryResponses;

namespace {serviceNamespacePart};

internal static class ValidationExtensions
{{
    public static IServiceCollection AddValidators(this IServiceCollection services)
    {{
        {formattedRegistrations}

        return services;
    }}
}}
";

            return (source, "ValidationExtensions");
        }

        private static string GetRequestNamespacePart(string restMethod)
        {
            switch (restMethod)
            {
                case "get":
                    return "Queries";
                case "post":
                    return "Commands";
                case "delete":
                    return "Queries";
                default:
                    throw new NotSupportedException($"Rest method {restMethod} is not supported.");
            }
        }
    }
}
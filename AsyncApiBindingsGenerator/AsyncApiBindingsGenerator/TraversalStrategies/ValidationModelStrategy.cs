using System;
using System.Collections.Generic;
using System.Linq;
using AsyncApiBindingsGenerator.Utils;
using ByteBard.AsyncAPI.Models;

namespace AsyncApiBindingsGenerator.TraversalStrategies
{
    internal class ValidationModelStrategy : ITraversalStrategy<ValidationModelsInput, (string, string)>
    {
        public (string, string) ProcessParent(ValidationModelsInput input, AsyncApiDocument spec)
        {
            var schema = input.Schema;
            var serviceNamespacePart = input.ServiceNamespacePart;
            var requestNamespacePart = input.RequestNamespacePart;
            var className = input.ClassName;
            var requestTypeName = input.RequestTypeName;

            var rules = CreateValidationRules(schema, spec).Where(rule => rule != string.Empty);
            var formattedRules = string.Join(@"
        ", rules);

            var source = $@"// <auto-generated/>
#nullable restore

using FluentValidation;
using {serviceNamespacePart}.Application.{requestNamespacePart};

namespace {serviceNamespacePart}.Api.Validators;

internal class {className} : AbstractValidator<{requestTypeName}>
{{
    public {className}()
    {{
        {formattedRules}
    }}
}}
";

            return (source, className);
        }

        public ValidationModelsInput ProcessChild(KeyValuePair<string, AsyncApiJsonSchema> propertyEntry, ValidationModelsInput parentInput, AsyncApiDocument spec)
        {
            var propertyName = propertyEntry.Key;
            var propertyValue = propertyEntry.Value;

            var childSchema = propertyValue.Type == SchemaType.Array
                ? propertyValue.Items
                : propertyValue;

            var childRequestTypeName = propertyValue.Type == SchemaType.Array
                ? StringUtils.ToPascalCase(spec.Components.Schemas.First(entry => propertyValue.Items.Equals(entry.Value.Schema)).Key)
                : StringUtils.ToPascalCase(propertyName);

            var childClassName = $"{childRequestTypeName}Validator";

            return new ValidationModelsInput
            {
                Schema = childSchema,
                ServiceNamespacePart = parentInput.ServiceNamespacePart,
                RequestNamespacePart = "Models",
                RequestTypeName = childRequestTypeName,
                ClassName = childClassName,
            };
        }

        private static IEnumerable<string> CreateValidationRules(AsyncApiJsonSchema schema, AsyncApiDocument spec)
        {
            return schema.Properties
                .Select(propertyEntry =>
                {
                    var propertyName = propertyEntry.Key;
                    var propertyValue = propertyEntry.Value;

                    var ruleFor = propertyValue.Type == SchemaType.Array
                        ? "RuleForEach"
                        : "RuleFor";

                    string validations = CreateChainedValidations(propertyName, propertyValue, spec);

                    return validations == string.Empty
                        ? string.Empty
                        : $"{ruleFor}(x => x.{StringUtils.ToPascalCase(propertyName)}){validations};";
                });
        }

        private static string CreateChainedValidations(string propertyName, AsyncApiJsonSchema propertyValue, AsyncApiDocument spec)
        {
            string validatorName;

            switch (propertyValue.Type)
            {
                case SchemaType.Array:
                    if (propertyValue.Items.Type == SchemaType.Object)
                    {
                        validatorName = StringUtils.ToPascalCase(spec.Components.Schemas.First(entry => propertyValue.Items.Equals(entry.Value.Schema)).Key);
                        return $".SetValidator(new {StringUtils.ToPascalCase(validatorName)}Validator())";
                    }
                    else
                    {
                        return string.Empty;
                    }
                case SchemaType.Object:
                    validatorName = StringUtils.ToPascalCase(spec.Components.Schemas.First(entry => propertyValue.Items.Equals(entry.Value.Schema)).Key);
                    return $".SetValidator(new {StringUtils.ToPascalCase(validatorName)}Validator())";
                case SchemaType.Integer:
                    var minimumSpan = propertyValue.Minimum != null
                        ? $".GreaterThanOrEqualTo({propertyValue.Minimum.Value})"
                        : string.Empty;

                    var maximumSpan = propertyValue.Maximum != null
                        ? $".LessThanOrEqualTo({propertyValue.Maximum.Value})"
                        : string.Empty;

                    return string.Concat(minimumSpan, maximumSpan);
                default:
                    return string.Empty;
            }
        }

    }
}

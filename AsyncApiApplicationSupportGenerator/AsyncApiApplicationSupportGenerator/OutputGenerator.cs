using System;
using System.Collections.Generic;
using System.Linq;
using AsyncApiApplicationSupportGenerator.OperationInterfaceTypeStrategies;
using AsyncApiApplicationSupportGenerator.OperationModelStrategies;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;

namespace AsyncApiApplicationSupportGenerator
{
    internal static class OutputGenerator
    {
        public static IEnumerable<(string source, string className)> GenerateInterfacesOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var outputs = spec.Operations.Values.Select(operation =>
            {
                var @namespace = $"{assemblyName}.Handlers";
                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();
                var operationType = GetInterfaceOperationStrategy(restMethod, pathPart, assemblyName);
                var requestType = GetType(spec, messageReference, operationType.RequestBodyNotPresent(), operationType.RequestBodyPresent());

                var replyMessageReference = operation.Reply.Messages.First();
                var responseType = GetType(spec, replyMessageReference, operationType.ResponseBodyNotPresent(), operationType.ResponseBodyPresent());

                var formattedGenericTypes = string.Join(", ", new List<string>() { requestType, responseType }.Where(t => t != string.Empty));

                var interfaceName = $"I{StringUtils.ToPascalCase(restMethod)}{StringUtils.ToPascalCase(pathPart)}Handler";
                var parentInterfaceName = $"I{StringUtils.ToPascalCase(restMethod)}Handler<{formattedGenericTypes}>";

                var source =
$@"// <auto-generated/>
#nullable restore

using Service.Application.Common.Handlers;

namespace {@namespace};

public interface {interfaceName} : {parentInterfaceName}
{{
}}
";
                return (source, interfaceName);
            });

            return outputs;
        }

        public static IEnumerable<(string source, string className)> GenerateModelOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var topLevelSchemas = spec.Operations.Values.SelectMany(operation =>
            {
                var typeSchemasToProcess = new List<(string, string, AsyncApiJsonSchema)>();

                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();

                AddToSchemasToProcess(assemblyName, typeSchemasToProcess, restMethod, pathPart, messageReference, OperationType.Request);

                var replyMessageReference = operation.Reply.Messages.First();
                AddToSchemasToProcess(assemblyName, typeSchemasToProcess, restMethod, pathPart, replyMessageReference, OperationType.Response);

                return typeSchemasToProcess;
            });

            var outputs = ProcessSchemaInfo(topLevelSchemas, new Dictionary<AsyncApiJsonSchema, bool>(), assemblyName, spec);

            return outputs;
        }

        private static void AddToSchemasToProcess(string assemblyName, List<(string, string, AsyncApiJsonSchema)> typeSchemasToProcess, string restMethod, string pathPart, AsyncApiMessageReference messageReference, OperationType operationType)
        {
            var bodyEntry = GetBodyEntry(messageReference);

            if (!bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                var operationStrategy = GetModelStrategy(restMethod, pathPart, assemblyName, operationType);
                typeSchemasToProcess.Add((operationStrategy.Namespace(), operationStrategy.TypeName(), bodyEntry.Value));
            }
        }

        private static IEnumerable<(string source, string className)> ProcessSchemaInfo(IEnumerable<(string, string, AsyncApiJsonSchema)> topLevelSchemas, Dictionary<AsyncApiJsonSchema, bool> dictionary, string assemblyName, AsyncApiDocument spec)
        {
            var outputs = topLevelSchemas.Select(((string @namespace, string typeName, AsyncApiJsonSchema schema) info) =>
            {
                var properties = info.schema.Properties;
                var formattedItems = properties.Select(property =>
                {
                    var propertyName = property.Key;
                    var propertyNamespace = property.Value.Type == SchemaType.Array
                        ? $"{assemblyName}.Models."
                        : string.Empty;
                    var memberType = GetMemberType(property.Value, spec);
                    var arrayBrackets = property.Value.Type == SchemaType.Array
                        ? "[]"
                        : string.Empty;
                    var formattedItem = $@"    [JsonPropertyName(""{propertyName}"")]
    public {propertyNamespace}{memberType}{arrayBrackets} {StringUtils.ToPascalCase(property.Key)} {{ get; init; }}";

                    return formattedItem;
                });

                var source =
$@"// <auto-generated/>
#nullable restore

using System.Text.Json.Serialization;

namespace {info.@namespace};

public readonly struct {info.typeName}
{{
{string.Join(@"
", formattedItems)}
}}
";

                return (source, info.typeName);
            });

            return outputs;
        }

        private static string GetMemberType(AsyncApiJsonSchema schema, AsyncApiDocument spec)
        {
            switch (schema.Type)
            {
                case SchemaType.Array:
                    var type = spec.Components.Schemas.First(schemaEntry => schema.Items.Equals(schemaEntry.Value.Schema)).Key;
                    return StringUtils.ToPascalCase(type);
                default:
                    throw new InvalidOperationException($"Schema type '{schema}' not supported. ");
            }
        }

        private static IOperationModelStrategy GetModelStrategy(string restMethod, string pathPart, string assemblyName, OperationType operationType)
        {
            if (restMethod == "get" && operationType == OperationType.Request)
            {
                return new QueryOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "get" && operationType == OperationType.Response)
            {
                return new QueryResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Request)
            {
                return new CommandOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Response)
            {
                return new CommandResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }

            throw new ArgumentException($"Rest method {restMethod} not supported.");
        }

        private static (string restMethod, string pathPart) GetAddressParts(AsyncApiOperation operation)
        {
            var address = operation.Channel.Address;
            var addressParts = address.Split('.');

            return (addressParts.First(), addressParts.ElementAt(1));
        }

        private static IOperationInterfaceTypeStrategy GetInterfaceOperationStrategy(string restMethod, string pathPart, string assemblyName)
        {
            switch (restMethod)
            {
                case "get":
                    return new QueryOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                case "post":
                    return new CommandOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                default:
                    throw new ArgumentException($"Rest method {restMethod} not supported.");
            }
        }

        private static string GetType(AsyncApiDocument spec, AsyncApiMessageReference messageReference, string noBodyValue, string hasBodyValue)
        {
            KeyValuePair<string, AsyncApiJsonSchema> bodyEntry = GetBodyEntry(messageReference);

            if (bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                return noBodyValue;
            }

            return hasBodyValue;
        }

        private static KeyValuePair<string, AsyncApiJsonSchema> GetBodyEntry(AsyncApiMessageReference messageReference)
        {
            return messageReference
                .Payload.Schema.As<AsyncApiJsonSchema>()
                .Properties.FirstOrDefault(prop => prop.Key == "body");
        }
    }
}
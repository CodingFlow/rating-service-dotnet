using System;
using System.Collections.Generic;
using System.Linq;
using AsyncApiApplicationSupportGenerator.OperationInterfaceTypeStrategies;
using AsyncApiApplicationSupportGenerator.OperationModelStrategies;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;

namespace AsyncApiApplicationSupportGenerator
{
    internal static class OutputGenerator
    {
        public static IEnumerable<(string source, string className)> GenerateInterfacesOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var outputs = spec.Operations.Values.Select(operation =>
            {
                var @namespace = $"{assemblyName}.Handlers";
                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();
                var operationType = GetInterfaceOperationStrategy(restMethod, pathPart, assemblyName);
                var requestType = GetType(spec, messageReference, operationType.RequestBodyNotPresent(), operationType.RequestBodyPresent());

                var replyMessageReference = operation.Reply.Messages.First();
                var responseType = GetType(spec, replyMessageReference, operationType.ResponseBodyNotPresent(), operationType.ResponseBodyPresent());

                var formattedGenericTypes = string.Join(", ", new List<string>() { requestType, responseType }.Where(t => t != string.Empty));

                var interfaceName = $"I{StringUtils.ToPascalCase(restMethod)}{StringUtils.ToPascalCase(pathPart)}Handler";
                var parentInterfaceName = $"IHandler<{formattedGenericTypes}>";

                var source =
$@"// <auto-generated/>
#nullable restore

using Service.Application.Common.Handlers;

namespace {@namespace};

public interface {interfaceName} : {parentInterfaceName}
{{
}}
";
                return (source, interfaceName);
            });

            return outputs;
        }

        public static IEnumerable<(string source, string className)> GenerateModelOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var topLevelSchemaInfos = spec.Operations.Values.SelectMany(operation =>
            {
                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();
                var requestSchemaInfos = AddToSchemasToProcess(assemblyName, restMethod, pathPart, messageReference, OperationType.Request, spec);

                var replyMessageReference = operation.Reply.Messages.First();
                var responseSchemaInfos = AddToSchemasToProcess(assemblyName, restMethod, pathPart, replyMessageReference, OperationType.Response, spec);

                var typeSchemasToProcess = requestSchemaInfos.Concat(responseSchemaInfos);

                return typeSchemasToProcess;
            });

            var outputs = ProcessSchemaInfo(topLevelSchemaInfos, assemblyName, spec).Distinct();

            return outputs;
        }

        private static IEnumerable<(string, string, AsyncApiJsonSchema)> AddToSchemasToProcess(string assemblyName, string restMethod, string pathPart, AsyncApiMessageReference messageReference, OperationType operationType, AsyncApiDocument spec)
        {
            var schemaInfos = Enumerable.Empty<(string, string, AsyncApiJsonSchema)>();
            
            if (HasBody(messageReference))
            {
                var bodyEntry = GetBodyEntry(messageReference);
                var operationStrategy = GetModelStrategy(restMethod, pathPart, assemblyName, operationType);
                var schemaInfo = (operationStrategy.Namespace(), operationStrategy.TypeName(), bodyEntry.Value);
                var childSchemaInfos = GetChildSchemaInfos(assemblyName, spec, schemaInfo);

                schemaInfos = new List<(string, string, AsyncApiJsonSchema)>() { schemaInfo };
                schemaInfos = schemaInfos.Concat(childSchemaInfos);
            }

            return schemaInfos;
        }

        private static IEnumerable<(string source, string className)> ProcessSchemaInfo(IEnumerable<(string, string, AsyncApiJsonSchema)> schemaInfos, string assemblyName, AsyncApiDocument spec)
        {
            return schemaInfos.Select(info => CreateModelSource(info, assemblyName, spec));
        }

        private static (string source, string typeName) CreateModelSource((string @namespace, string typeName, AsyncApiJsonSchema schema) info, string assemblyName, AsyncApiDocument spec)
        {
            // TODO: Refactor to specify when type is response and pass it in instead of relying on naming convention.
            var isResponse = info.typeName.Contains("Response");

            var properties = info.schema.Properties;

            var formattedItems = properties.Select(property =>
            {
                var propertyName = property.Key;
                var propertyNamespace = property.Value.Type == SchemaType.Array
                    ? $"{assemblyName}.Models."
                    : string.Empty;
                var memberType = GetMemberType(property.Value, spec, propertyNamespace);
                var wholeType = property.Value.Type == SchemaType.Array
                    ? $"IEnumerable<{memberType}>"
                    : $"{memberType}";
                var required = property.Value.Type == SchemaType.Array && isResponse
                    ? " required"
                    : string.Empty;
                var initializer = property.Value.Type == SchemaType.Array && !isResponse
                    ? $" = new List<{memberType}>();"
                    : string.Empty;

                var formattedItem = $@"    [JsonPropertyName(""{propertyName}"")]
    public{required} {wholeType} {StringUtils.ToPascalCase(property.Key)} {{ get; init; }}{initializer}";

                return formattedItem;
            });

            var source =
$@"// <auto-generated/>
#nullable restore

using System.Text.Json.Serialization;

namespace {info.@namespace};

public readonly record struct {info.typeName}()
{{
{string.Join(@"

", formattedItems)}
}}
";

            return (source, info.typeName);
        }

        private static IEnumerable<(string @namespace, string typeName, AsyncApiJsonSchema schema)> GetChildSchemaInfos(string assemblyName, AsyncApiDocument spec, (string @namespace, string typeName, AsyncApiJsonSchema schema) info)
        {
            return info.schema.Properties
                .Where(property =>
                {
                    var schema = property.Value;

                    return schema.Type == SchemaType.Array && (schema.Items.Type == SchemaType.Object || schema.Items.Type == SchemaType.Array)
                        || schema.Type == SchemaType.Object;
                })
                .Select(property =>
                {
                    var schema = property.Value;
                    var @namespace = $"{assemblyName}.Models";
                    var typeName = spec.Components.Schemas.First(entry => schema.Items.Equals(entry.Value.Schema)).Key;

                    var schemaToProcess = schema.Type == SchemaType.Array
                        ? schema.Items
                        : schema;

                    return (@namespace, StringUtils.ToPascalCase(typeName), schemaToProcess);
                });
        }

        private static string GetMemberType(AsyncApiJsonSchema schema, AsyncApiDocument spec, string propertyNamespace)
        {
            switch (schema.Type)
            {
                case SchemaType.Array:
                    string type;

                    if (schema.Items.Type == SchemaType.Object)
                    {
                        var objectType = StringUtils.ToPascalCase(spec.Components.Schemas.First(schemaEntry => schema.Items.Equals(schemaEntry.Value.Schema)).Key);
                        type = $"{propertyNamespace}{objectType}";
                    }
                    else
                    {
                        type = GetMemberType(schema.Items, spec, propertyNamespace);
                    }

                    return type;
                case SchemaType.Integer:
                    return "int";
                case SchemaType.String:
                    return schema.Format == "uuid"
                        ? "Guid"
                        : "string";
                default:
                    throw new InvalidOperationException($"Schema type '{schema.Type}' not supported. ");
            }
        }

        private static IOperationModelStrategy GetModelStrategy(string restMethod, string pathPart, string assemblyName, OperationType operationType)
        {
            if (restMethod == "get" && operationType == OperationType.Request
                || restMethod == "delete" && operationType == OperationType.Request)
            {
                return new QueryOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "get" && operationType == OperationType.Response
                || restMethod == "get" && operationType == OperationType.Response)
            {
                return new QueryResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Request)
            {
                return new CommandOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Response)
            {
                return new CommandResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }

            throw new ArgumentException($"Rest method {restMethod} not supported.");
        }

        private static (string restMethod, string pathPart) GetAddressParts(AsyncApiOperation operation)
        {
            var address = operation.Channel.Address;
            var addressParts = address.Split('.');

            return (addressParts.First(), addressParts.ElementAt(1));
        }

        private static IOperationInterfaceTypeStrategy GetInterfaceOperationStrategy(string restMethod, string pathPart, string assemblyName)
        {
            switch (restMethod)
            {
                case "get":
                    return new QueryOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                case "delete":
                    return new QueryOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                case "post":
                    return new CommandOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                default:
                    throw new ArgumentException($"Rest method {restMethod} not supported.");
            }
        }

        private static string GetType(AsyncApiDocument spec, AsyncApiMessageReference messageReference, string noBodyValue, string hasBodyValue)
        {
            KeyValuePair<string, AsyncApiJsonSchema> bodyEntry = GetBodyEntry(messageReference);

            if (bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                return noBodyValue;
            }

            return hasBodyValue;
        }

        private static bool HasBody(AsyncApiMessageReference messageReference)
        {
            var bodyEntry = GetBodyEntry(messageReference);

            return !bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>));
        }

        private static KeyValuePair<string, AsyncApiJsonSchema> GetBodyEntry(AsyncApiMessageReference messageReference)
        {
            return messageReference
                .Payload.Schema.As<AsyncApiJsonSchema>()
                .Properties.FirstOrDefault(prop => prop.Key == "body");
        }
    }
}
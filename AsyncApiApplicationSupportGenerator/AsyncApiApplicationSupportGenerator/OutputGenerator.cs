using System;
using System.Collections.Generic;
using System.Linq;
using AsyncApiApplicationSupportGenerator.OperationInterfaceTypeStrategies;
using AsyncApiApplicationSupportGenerator.OperationModelStrategies;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;

namespace AsyncApiApplicationSupportGenerator
{
    internal static class OutputGenerator
    {
        public static IEnumerable<(string source, string className)> GenerateInterfacesOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var outputs = spec.Operations.Values.Select(operation =>
            {
                var @namespace = $"{assemblyName}.Handlers";
                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();
                var operationType = GetInterfaceOperationStrategy(restMethod, pathPart, assemblyName);
                var requestType = GetType(spec, messageReference, operationType.RequestBodyNotPresent(), operationType.RequestBodyPresent());

                var replyMessageReference = operation.Reply.Messages.First();
                var responseType = GetType(spec, replyMessageReference, operationType.ResponseBodyNotPresent(), operationType.ResponseBodyPresent());

                var formattedGenericTypes = string.Join(", ", new List<string>() { requestType, responseType }.Where(t => t != string.Empty));

                var interfaceName = $"I{StringUtils.ToPascalCase(restMethod)}{StringUtils.ToPascalCase(pathPart)}Handler";
                var parentInterfaceName = $"I{StringUtils.ToPascalCase(restMethod)}Handler<{formattedGenericTypes}>";

                var source =
$@"// <auto-generated/>
#nullable restore

using Service.Application.Common.Handlers;

namespace {@namespace};

public interface {interfaceName} : {parentInterfaceName}
{{
}}
";
                return (source, interfaceName);
            });

            return outputs;
        }

        public static IEnumerable<(string source, string className)> GenerateModelOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var topLevelSchemaInfos = spec.Operations.Values.SelectMany(operation =>
            {
                var typeSchemasToProcess = new List<(string, string, AsyncApiJsonSchema)>();

                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();

                AddToSchemasToProcess(assemblyName, typeSchemasToProcess, restMethod, pathPart, messageReference, OperationType.Request);

                var replyMessageReference = operation.Reply.Messages.First();
                AddToSchemasToProcess(assemblyName, typeSchemasToProcess, restMethod, pathPart, replyMessageReference, OperationType.Response);

                return typeSchemasToProcess;
            });

            var outputs = ProcessSchemaInfo(topLevelSchemaInfos, new HashSet<AsyncApiJsonSchema>(), assemblyName, spec).Distinct();

            return outputs;
        }

        private static void AddToSchemasToProcess(string assemblyName, List<(string, string, AsyncApiJsonSchema)> typeSchemasToProcess, string restMethod, string pathPart, AsyncApiMessageReference messageReference, OperationType operationType)
        {
            var bodyEntry = GetBodyEntry(messageReference);

            if (!bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                var operationStrategy = GetModelStrategy(restMethod, pathPart, assemblyName, operationType);
                typeSchemasToProcess.Add((operationStrategy.Namespace(), operationStrategy.TypeName(), bodyEntry.Value));
            }
        }

        private static IEnumerable<(string source, string className)> ProcessSchemaInfo(IEnumerable<(string, string, AsyncApiJsonSchema)> schemaInfos, HashSet<AsyncApiJsonSchema> processedSchemas, string assemblyName, AsyncApiDocument spec)
        {
            var outputs = schemaInfos.Select(((string @namespace, string typeName, AsyncApiJsonSchema schema) info) =>
            {
                var properties = info.schema.Properties;
                var formattedItems = properties.Select(property =>
                {
                    var propertyName = property.Key;
                    var propertyNamespace = property.Value.Type == SchemaType.Array
                        ? $"{assemblyName}.Models."
                        : string.Empty;
                    var memberType = GetMemberType(property.Value, spec);
                    var arrayBrackets = property.Value.Type == SchemaType.Array
                        ? "[]"
                        : string.Empty;
                    var formattedItem = $@"    [JsonPropertyName(""{propertyName}"")]
    public {propertyNamespace}{memberType}{arrayBrackets} {StringUtils.ToPascalCase(property.Key)} {{ get; init; }}";

                    return formattedItem;
                });

                var source =
$@"// <auto-generated/>
#nullable restore

using System.Text.Json.Serialization;

namespace {info.@namespace};

public readonly struct {info.typeName}
{{
{string.Join(@"

", formattedItems)}
}}
";

                return (source, info.typeName);
            });

            foreach (var (@namespace, typeName, schema) in schemaInfos)
            {
                processedSchemas.Add(schema);
            }

            var schemaInfosToProcess = schemaInfos.SelectMany(info => GetChildSchemaInfos(assemblyName, spec, info));

            var childOutputs = schemaInfosToProcess.Any()
                ? ProcessSchemaInfo(schemaInfosToProcess, processedSchemas, assemblyName, spec)
                : new List<(string, string)>();

            return outputs.Concat(childOutputs);
        }

        private static IEnumerable<(string @namespace, string typeName, AsyncApiJsonSchema schema)> GetChildSchemaInfos(string assemblyName, AsyncApiDocument spec, (string @namespace, string typeName, AsyncApiJsonSchema schema) info)
        {
            return info.schema.Properties
                .Where(property => property.Value.Type == SchemaType.Array || property.Value.Type == SchemaType.Object)
                .Select(property =>
                {
                    var schema = property.Value;
                    var @namespace = $"{assemblyName}.Models";
                    var typeName = schema.Type == SchemaType.Array
                        ? spec.Components.Schemas.First(entry => schema.Items.Equals(entry.Value.Schema)).Key
                        : spec.Components.Schemas.First(entry => schema.Equals(entry.Value.Schema)).Key;
                    
                    var schemaToProcess = schema.Type == SchemaType.Array
                        ? schema.Items
                        : schema;

                    return (@namespace, StringUtils.ToPascalCase(typeName), schemaToProcess);
                });
        }

        private static string GetMemberType(AsyncApiJsonSchema schema, AsyncApiDocument spec)
        {
            switch (schema.Type)
            {
                case SchemaType.Array:
                    var type = spec.Components.Schemas.First(schemaEntry => schema.Items.Equals(schemaEntry.Value.Schema)).Key;
                    return StringUtils.ToPascalCase(type);
                case SchemaType.Integer:
                    return "int";
                case SchemaType.String:
                    return "string";
                default:
                    throw new InvalidOperationException($"Schema type '{schema.Type}' not supported. ");
            }
        }

        private static IOperationModelStrategy GetModelStrategy(string restMethod, string pathPart, string assemblyName, OperationType operationType)
        {
            if (restMethod == "get" && operationType == OperationType.Request)
            {
                return new QueryOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "get" && operationType == OperationType.Response)
            {
                return new QueryResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Request)
            {
                return new CommandOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Response)
            {
                return new CommandResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }

            throw new ArgumentException($"Rest method {restMethod} not supported.");
        }

        private static (string restMethod, string pathPart) GetAddressParts(AsyncApiOperation operation)
        {
            var address = operation.Channel.Address;
            var addressParts = address.Split('.');

            return (addressParts.First(), addressParts.ElementAt(1));
        }

        private static IOperationInterfaceTypeStrategy GetInterfaceOperationStrategy(string restMethod, string pathPart, string assemblyName)
        {
            switch (restMethod)
            {
                case "get":
                    return new QueryOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                case "post":
                    return new CommandOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                default:
                    throw new ArgumentException($"Rest method {restMethod} not supported.");
            }
        }

        private static string GetType(AsyncApiDocument spec, AsyncApiMessageReference messageReference, string noBodyValue, string hasBodyValue)
        {
            KeyValuePair<string, AsyncApiJsonSchema> bodyEntry = GetBodyEntry(messageReference);

            if (bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                return noBodyValue;
            }

            return hasBodyValue;
        }

        private static KeyValuePair<string, AsyncApiJsonSchema> GetBodyEntry(AsyncApiMessageReference messageReference)
        {
            return messageReference
                .Payload.Schema.As<AsyncApiJsonSchema>()
                .Properties.FirstOrDefault(prop => prop.Key == "body");
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using AsyncApiApplicationSupportGenerator.OperationInterfaceTypeStrategies;
using AsyncApiApplicationSupportGenerator.OperationModelStrategies;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;

namespace AsyncApiApplicationSupportGenerator
{
    internal static class OutputGenerator
    {
        public static IEnumerable<(string source, string className)> GenerateInterfacesOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var outputs = spec.Operations.Values.Select(operation =>
            {
                var @namespace = $"{assemblyName}.Handlers";
                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();
                var operationType = GetInterfaceOperationStrategy(restMethod, pathPart, assemblyName);
                var requestType = GetType(spec, messageReference, operationType.RequestBodyNotPresent(), operationType.RequestBodyPresent());

                var replyMessageReference = operation.Reply.Messages.First();
                var responseType = GetType(spec, replyMessageReference, operationType.ResponseBodyNotPresent(), operationType.ResponseBodyPresent());

                var formattedGenericTypes = string.Join(", ", new List<string>() { requestType, responseType }.Where(t => t != string.Empty));

                var interfaceName = $"I{StringUtils.ToPascalCase(restMethod)}{StringUtils.ToPascalCase(pathPart)}Handler";
                var parentInterfaceName = $"I{StringUtils.ToPascalCase(restMethod)}Handler<{formattedGenericTypes}>";

                var source =
$@"// <auto-generated/>
#nullable restore

using Service.Application.Common.Handlers;

namespace {@namespace};

public interface {interfaceName} : {parentInterfaceName}
{{
}}
";
                return (source, interfaceName);
            });

            return outputs;
        }

        public static IEnumerable<(string source, string className)> GenerateModelOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var topLevelSchemaInfos = spec.Operations.Values.SelectMany(operation =>
            {
                var typeSchemasToProcess = new List<(string, string, AsyncApiJsonSchema)>();

                var (restMethod, pathPart) = GetAddressParts(operation);

                var messageReference = operation.Messages.First();

                AddToSchemasToProcess(assemblyName, typeSchemasToProcess, restMethod, pathPart, messageReference, OperationType.Request);

                var replyMessageReference = operation.Reply.Messages.First();
                AddToSchemasToProcess(assemblyName, typeSchemasToProcess, restMethod, pathPart, replyMessageReference, OperationType.Response);

                return typeSchemasToProcess;
            });

            var outputs = ProcessSchemaInfo(topLevelSchemaInfos, new HashSet<AsyncApiJsonSchema>(), assemblyName, spec).Distinct();

            return outputs;
        }

        private static void AddToSchemasToProcess(string assemblyName, List<(string, string, AsyncApiJsonSchema)> typeSchemasToProcess, string restMethod, string pathPart, AsyncApiMessageReference messageReference, OperationType operationType)
        {
            var bodyEntry = GetBodyEntry(messageReference);

            if (!bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                var operationStrategy = GetModelStrategy(restMethod, pathPart, assemblyName, operationType);
                typeSchemasToProcess.Add((operationStrategy.Namespace(), operationStrategy.TypeName(), bodyEntry.Value));
            }
        }

        private static IEnumerable<(string source, string className)> ProcessSchemaInfo(IEnumerable<(string, string, AsyncApiJsonSchema)> schemaInfos, HashSet<AsyncApiJsonSchema> processedSchemas, string assemblyName, AsyncApiDocument spec)
        {
            var outputs = schemaInfos.Select(((string @namespace, string typeName, AsyncApiJsonSchema schema) info) =>
            {
                // TODO: Refactor to specify when type is response and pass it in instead of relying on naming convention.
                var isResponse = info.typeName.Contains("Response");
                
                var properties = info.schema.Properties;

                var constructorParameters = string.Join(", ", properties.Select(property =>
                {
                    var propertyNamespace = property.Value.Type == SchemaType.Array
                        ? $"{assemblyName}.Models."
                        : string.Empty;
                    var memberType = GetMemberType(property.Value, spec, propertyNamespace);
                    var wholeType = property.Value.Type == SchemaType.Array
                        ? $"List<{memberType}>"
                        : $"{memberType}";

                    return $@"{wholeType} {property.Key}";
                }));

                var assignCollections = string.Join(@"
", properties.Select(p => p.Value.Type == SchemaType.Array
                    ? $"this.{StringUtils.ToPascalCase(p.Key)} = {p.Key} ?? new();"
                    : string.Empty)
                    .Where(a => a != string.Empty));
                
                var formattedItems = properties.Select(property =>
                {
                    var propertyName = property.Key;
                    var propertyNamespace = property.Value.Type == SchemaType.Array
                        ? $"{assemblyName}.Models."
                        : string.Empty;
                    var memberType = GetMemberType(property.Value, spec, propertyNamespace);
                    var wholeType = property.Value.Type == SchemaType.Array
                        ? $"List<{memberType}>"
                        : $"{memberType}";
                    var required = property.Value.Type == SchemaType.Array && isResponse
                        ? " required"
                        : string.Empty;
                    var initializer = property.Value.Type == SchemaType.Array && !isResponse
                        ? $" = new IEnumerable<{memberType}>();"
                        : string.Empty;

                    var formattedItem = $@"    [JsonPropertyName(""{propertyName}"")]
    public{required} {wholeType} {StringUtils.ToPascalCase(property.Key)} {{ get; init; }}";

                    return formattedItem;
                });

                var source =
$@"// <auto-generated/>
#nullable restore

using System.Text.Json.Serialization;

namespace {info.@namespace};

public readonly struct {info.typeName}
{{
    [JsonConstructor]
    public {info.typeName}({constructorParameters})
    {{
        {assignCollections}
    }}

{string.Join(@"

", formattedItems)}
}}
";

                return (source, info.typeName);
            });

            foreach (var (@namespace, typeName, schema) in schemaInfos)
            {
                processedSchemas.Add(schema);
            }

            var schemaInfosToProcess = schemaInfos.SelectMany(info => GetChildSchemaInfos(assemblyName, spec, info));

            var childOutputs = schemaInfosToProcess.Any()
                ? ProcessSchemaInfo(schemaInfosToProcess, processedSchemas, assemblyName, spec)
                : new List<(string, string)>();

            return outputs.Concat(childOutputs);
        }

        private static IEnumerable<(string @namespace, string typeName, AsyncApiJsonSchema schema)> GetChildSchemaInfos(string assemblyName, AsyncApiDocument spec, (string @namespace, string typeName, AsyncApiJsonSchema schema) info)
        {
            return info.schema.Properties
                .Where(property =>
                {
                    var schema = property.Value;

                    return schema.Type == SchemaType.Array && (schema.Items.Type == SchemaType.Object || schema.Items.Type == SchemaType.Array)
                        || schema.Type == SchemaType.Object;
                })
                .Select(property =>
                {
                    var schema = property.Value;
                    var @namespace = $"{assemblyName}.Models";
                    var typeName = spec.Components.Schemas.First(entry => schema.Items.Equals(entry.Value.Schema)).Key;

                    var schemaToProcess = schema.Type == SchemaType.Array
                        ? schema.Items
                        : schema;

                    return (@namespace, StringUtils.ToPascalCase(typeName), schemaToProcess);
                });
        }

        private static string GetMemberType(AsyncApiJsonSchema schema, AsyncApiDocument spec, string propertyNamespace)
        {
            switch (schema.Type)
            {
                case SchemaType.Array:
                    string type;

                    if (schema.Items.Type == SchemaType.Object)
                    {
                        var objectType = StringUtils.ToPascalCase(spec.Components.Schemas.First(schemaEntry => schema.Items.Equals(schemaEntry.Value.Schema)).Key);
                        type = $"{propertyNamespace}{objectType}";
                    }
                    else
                    {
                        type = GetMemberType(schema.Items, spec, propertyNamespace);
                    }

                    return type;
                case SchemaType.Integer:
                    return "int";
                case SchemaType.String:
                    return "string";
                default:
                    throw new InvalidOperationException($"Schema type '{schema.Type}' not supported. ");
            }
        }

        private static IOperationModelStrategy GetModelStrategy(string restMethod, string pathPart, string assemblyName, OperationType operationType)
        {
            if (restMethod == "get" && operationType == OperationType.Request
                || restMethod == "delete" && operationType == OperationType.Request)
            {
                return new QueryOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "get" && operationType == OperationType.Response
                || restMethod == "get" && operationType == OperationType.Response)
            {
                return new QueryResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Request)
            {
                return new CommandOperationModelStrategy(assemblyName, restMethod, pathPart);
            }
            else if (restMethod == "post" && operationType == OperationType.Response)
            {
                return new CommandResponseOperationModelStrategy(assemblyName, restMethod, pathPart);
            }

            throw new ArgumentException($"Rest method {restMethod} not supported.");
        }

        private static (string restMethod, string pathPart) GetAddressParts(AsyncApiOperation operation)
        {
            var address = operation.Channel.Address;
            var addressParts = address.Split('.');

            return (addressParts.First(), addressParts.ElementAt(1));
        }

        private static IOperationInterfaceTypeStrategy GetInterfaceOperationStrategy(string restMethod, string pathPart, string assemblyName)
        {
            switch (restMethod)
            {
                case "get":
                    return new QueryOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                case "delete":
                    return new QueryOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                case "post":
                    return new CommandOperationInterfaceTypeStrategy(assemblyName, restMethod, pathPart);
                default:
                    throw new ArgumentException($"Rest method {restMethod} not supported.");
            }
        }

        private static string GetType(AsyncApiDocument spec, AsyncApiMessageReference messageReference, string noBodyValue, string hasBodyValue)
        {
            KeyValuePair<string, AsyncApiJsonSchema> bodyEntry = GetBodyEntry(messageReference);

            if (bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                return noBodyValue;
            }

            return hasBodyValue;
        }

        private static KeyValuePair<string, AsyncApiJsonSchema> GetBodyEntry(AsyncApiMessageReference messageReference)
        {
            return messageReference
                .Payload.Schema.As<AsyncApiJsonSchema>()
                .Properties.FirstOrDefault(prop => prop.Key == "body");
        }
    }
}
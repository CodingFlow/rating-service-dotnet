using System;
using System.Collections.Generic;
using System.Linq;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;

namespace AsyncApiApplicationSupportGenerator
{
    internal static class OutputGenerator
    {
        public static IEnumerable<(string source, string className)> GenerateSpecOutputs(AsyncApiDocument spec, string assemblyName)
        {
            var outputs = spec.Operations.Values.Select(operation =>
            {
                var @namespace = $"{assemblyName}.Handlers";
                var address = operation.Channel.Address;
                var addressParts = address.Split('.');
                var (restMethod, pathPart) = (addressParts.First(), addressParts.ElementAt(1));

                var messageReference = operation.Messages.First();
                var operationType = GetOperationStrategy(restMethod, pathPart, assemblyName);
                var requestType = GetType(spec, messageReference, operationType.RequestBodyNotPresent(), operationType.RequestBodyPresent());

                var replyMessageReference = operation.Reply.Messages.First();
                var responseType = GetType(spec, replyMessageReference, operationType.ResponseBodyNotPresent(), operationType.ResponseBodyPresent());

                var formattedGenericTypes = string.Join(", ", new List<string>() { requestType, responseType }.Where(t => t != string.Empty));

                var interfaceName = $"I{StringUtils.ToPascalCase(restMethod)}{StringUtils.ToPascalCase(pathPart)}Handler";
                var parentInterfaceName = $"I{StringUtils.ToPascalCase(restMethod)}Handler<{formattedGenericTypes}>";

                var source =
$@"// <auto-generated/>
#nullable restore

using Service.Application.Common.Handlers;

namespace {@namespace};

public interface {interfaceName} : {parentInterfaceName}
{{
}}
";
                return (source, interfaceName);
            });

            return outputs;
        }

        private static IOperationTypeStrategy GetOperationStrategy(string restMethod, string pathPart, string assemblyName)
        {
            switch (restMethod)
            {
                case "get":
                    return new GetOperationTypeStrategy(assemblyName, pathPart);
                case "post":
                    return new PostOperationTypeStrategy(assemblyName, pathPart);
                default:
                    throw new ArgumentException($"Rest method {restMethod} not supported.");
            }
        }

        private static string GetType(AsyncApiDocument spec, AsyncApiMessageReference messageReference, string noBodyValue, string hasBodyValue)
        {
            var bodyEntry = messageReference
                                .Payload.Schema.As<AsyncApiJsonSchema>()
                                .Properties.FirstOrDefault(prop => prop.Key == "body");

            if (bodyEntry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>)))
            {
                return noBodyValue;
            }

            //var typeSchema = bodyEntry.Value;
            //var type = spec.Components.Schemas.First(schemaEntry => typeSchema.Equals(schemaEntry.Value.Schema)).Key;

            //var formattedType = type == string.Empty ? string.Empty : $"{type}[]";

            return hasBodyValue;
        }
    }
}
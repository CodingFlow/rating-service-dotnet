using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using ByteBard.AsyncAPI.Models;
using Microsoft.CodeAnalysis;

namespace RequestDecoratorGenerator
{
    internal static class OutputGenerator
    {
        public static (string source, string className) GenerateOutput(ImmutableArray<INamedTypeSymbol> types, AsyncApiDocument spec, string assemblyName)
        {
            var @namespace = assemblyName;
            var serviceNamespacePart = @namespace.Split('.').First();

            var decorations = types.SelectMany(type => CreateDecorationsForType(spec, $"{type.ContainingNamespace}.{type.Name}"));

            var formattedDecorations = string.Join(@"
        ", decorations);

            var source = $@"// <auto-generated/>
#nullable restore

using System.Text.Json.Nodes;
using Microsoft.Extensions.DependencyInjection;
using Service.Api.Common;
using {serviceNamespacePart}.Application.Commands;
using {serviceNamespacePart}.Application.Queries;
using {serviceNamespacePart}.Application.QueryResponses;

namespace {@namespace};

internal static class RequestDecoratorExtensions
{{
    public static IServiceCollection AddRequestDecorators(this IServiceCollection services)
    {{
        {formattedDecorations}

        return services;
    }}
}}
";

            return (source, "RequestDecoratorExtensions");
        }

        private static IEnumerable<string> CreateDecorationsForType(AsyncApiDocument spec, string typeName)
        {
            return spec.Operations.Values.Select(operation =>
            {
                var parts = operation.Channel.Address.Split('.');
                var (restMethod, pathPart) = (parts.First(), parts.ElementAt(1));

                var requestType = $"{ToPascalCase(restMethod)}{ToPascalCase(pathPart)}{GetRequestType(restMethod)}";

                var messageReference = operation.Reply.Messages.First();
                var hasResponseBody = IsPayloadPropertyExists(messageReference, "body");

                var responseType = hasResponseBody
                    ? $"{requestType}Response"
                    : "JsonObject";

                return $"services.Decorate<IResponseStrategy<{requestType}, {responseType}>, {typeName}<{requestType}, {responseType}>>();";
            });
        }

        private static bool IsPayloadPropertyExists(AsyncApiMessage messageReference, string propertyName)
        {
            var entry = GetPayloadSchemaEntry(messageReference, propertyName);

            return !entry.Equals(default(KeyValuePair<string, AsyncApiJsonSchema>));
        }

        private static KeyValuePair<string, AsyncApiJsonSchema> GetPayloadSchemaEntry(AsyncApiMessage messageReference, string propertyName)
        {
            return messageReference
                .Payload.Schema.As<AsyncApiJsonSchema>()
                .Properties.FirstOrDefault(prop => prop.Key == propertyName);
        }

        private static string GetRequestType(string restMethod)
        {
            switch (restMethod)
            {
                case "get":
                    return "Query";
                case "delete":
                    return "Command";
                case "post":
                    return "Command";
                default:
                    throw new ArgumentException($"Rest method '{restMethod}' not supported.");
            }
        }

        private static string ToPascalCase(string input)
        {
            return $"{char.ToUpper(input[0])}{input.Substring(1)}";
        }
    }
}